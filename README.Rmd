---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r readme_intro, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# aramappings

<!-- badges: start -->
<!-- badges: end -->

The goal of aramappings is to compute ...

Adaptable Radial Axes (ARA) plots [@Rubio17] are an interactive, exploratory data visualization technique related to Star Coordinates [@Kandogan00; @Kandogan01] and Biplots [@Gabriel71; @Gower95; @Hofmann04; @laGrange09; @Greenacre10]. ARA performs dimensionality reduction by representing high-dimensional numerical data as points in a plane or three-dimensional space. Unlike many other dimensionality reduction methods, ARA plots also visualize variable-specific information through "axis vectors" and their corresponding labeled axis lines, where each vector is associated with a particular data variable. These axis vectors (interactively defined by users, as in Star Coordinates) indicate the directions in which the values of their associated variables increase within the plot. Additionally, the high-dimensional observations are mapped (in an optimal sense) onto the plot in order to allow users to estimate variable values by visually projecting these points onto the labeled axes, as in Biplots.


## Overview

<!-- main components of the package. For more complex packages, this will point to vignettes for more details. -->


## Installation

Install a stable version from CRAN


<!--- ```{r install}
install.packages("aramappings")
``` -->

Install the development version of aramappings from [GitHub](https://github.com/) with:

<!--- ```{r install_dev}
# install.packages("pak")
pak::pak("manuelrubio/aramappings")
``` -->


## Example

We recommend starting an exploratory analysis using an unconstrained ARA plot with the $\ell^{2}$ norm, which can be generated very efficiently since the mappings ($\mathbf{P}$) can be obtained through a closed-form expression (i.e., a formula). The obvious first step is to load the **aramappings** package:

```{r}
# Load package
library(aramappings)
```

In the usage examples we will use the **Auto MPG** dataset available in packages **ascentTraining** and **grpnet**, Kaggle, or the UCI Machine Learning Repository [@Frank10]. In this case, we load the dataset in the **ascentTraining** package.

```{r}
# Load data
library(ascentTraining) # contains the Auto MPG dataset
data("auto_mpg")
```

Next, we select a subset of numerical variables from the dataset. The selected variables are specified through a vector containing their column indices in the original dataset. Furthermore, we rename the data set to `X`, simply for clarity with respect to the notation defined above.

```{r}
# Define subset of (numerical) variables
selected_variables <- c(1,4,5,6)   # 1:"mpg", 4:"horsepower", 5:"weight", 6:"acceleration")

# Retain only selected variables and rename dataset as X
X <- auto_mpg[, selected_variables] # Select a subset of variables
rm(auto_mpg)
```

The ARA functions halt if the data or other parameters contain missing values. Thus, we proceed eliminating any row (data observation) that contains missing values. Naturally, another approach consists of replacing missing values by some other substituted values (imputation).

```{r}
# Remove rows with missing values from X
N <- nrow(X)
rows_to_delete <- NULL
for (i in 1:N) {
  if (sum(is.na(X[i, ])) > 0) {
    rows_to_delete <- c(rows_to_delete, -i)
  }
}
X <- X[rows_to_delete, ]
```

At this moment `X` is a data.frame. In order to use the ARA functions we first need to convert it to a matrix:

```{r}
# Convert X to matrix
X <- apply(as.matrix.noquote(X), 2, as.numeric)
```

In addition, we strongly recommend standardizing the data when using ARA. We save the result in variable `Z` since the function that draws the plot needs the original values in `X`.

```{r}
# Standardize data
Z <- scale(X)
```


Having preprocessed the data, the next step consists of defining the axis vectors, which are the rows of $\mathbf{V}$. These can be obtained manually (ideally through a graphical user interface), or through an automatic method. For instante, $\mathbf{V}$ could be the matrix defining the Principal Component Analysis transfomation (in that case the ARA plot would be a Principal Component Biplot). In this example, we simply define a configuration of vectors in polar coordinates and transform them to Cartesian coordinates with the `pol2cart()` function in package **geometry**.

```{r}
# Define axis vectors (2-dimensional in this example)
library(geometry)
r <- c(0.8, 1, 1.2, 1)
theta <- c(225, 100, 315, 80) * 2 * pi / 360
V <- pol2cart(theta, r)
```

It is also possible to define weights in order to control the relative importance of estimating accurately on each axis. This is nevertheless complex, since the accuracy also depends on the length of the axis vectors. In this case, we have set two weigths to 1 and another two to 0.75. Visually, the weights determine the level of gray used to color the axis vectors in the ARA plot.

```{r}
# Define weights
weights <- c(1, 0.75, 0.75, 1)
```

Having defined the data (`Z`), axis vectors (`V`), and weights (`weights`), we can proceed to compute the ARA mapping. For unconstrained ARA plots with the $\ell^{2}$ norm the `solver` parameter should be set to "formula" (the default), in order to obtain the mapping through a closed-form expression. The following code computes the embedded points and saves them in `mapping$P`, and shows the execution runtime involved in computing the mapping.

```{r echo = T, results = 'show'}
# Compute the mapping and print the execution time
start <- Sys.time()
mapping <- ara_unconstrained_L2(
  Z,
  V,
  weights = weights,
  solver = "formula"
)
end <- Sys.time()
print(end - start, units = "secs")
```

ARA plots can get cluttered when showing all of the axis lines and corresponding labels at the tick marks. Thus, the function that we will use to draw the ARA plot (`draw_ara_plot_2d_standardized()`) contains a parameter called `axis_lines` for specifying the subset of axis lines (and labels) we wish to visualize. In this example we will show the axes associated with variables "mpg" and "acceleration". Note that in the original data frame these were variables 1 and 6. However, since we only retained four variables ("mpg", "horsepower", "weight", and "acceleration"), the column index of "acceleration" is now 4.

```{r}
# Select variables with labeled axis lines on ARA plot
axis_lines <- c(1,4)   # 1:"mpg", 4:"acceleration")
```

Also, the plotted points can be colored according to the values of a particular variable. In this example, we will color the points according to the value of variable "mpg".

```{r}
# Select variable used for coloring embedded points
color_variable <- 1    # "mpg"
```

Finally, we generate the ARA plot by calling `draw_ara_plot_2d_standardized()`:

```{r fig.show='hide'}
# Draw the ARA plot
draw_ara_plot_2d_standardized(
  Z,
  X,
  V,
  mapping$P,
  weights = weights,
  axis_lines = axis_lines,
  color_variable = color_variable
)
```

```{r unc_L2, echo=FALSE, fig.cap="Unconstrained ARA plot with the L2 norm of a subset of the Autompg dataset.", out.width = '100%'}
knitr::include_graphics("man/figures/autompg_unconstrained_L2.svg")
```
